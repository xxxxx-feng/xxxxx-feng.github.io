(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{400:function(e,t,o){"use strict";o.r(t);var s=o(44),n=Object(s.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("p",[o("strong",[e._v("js跨域如何解决")])]),e._v(" "),o("p",[e._v("目前暂时已知的跨域方法是：")]),e._v(" "),o("ol",[o("li",[e._v("jsonp跨域，原理：script标签没有跨域限制的漏洞实现的一种跨域方法，只支持get请求。安全问题会受到威胁。")]),e._v(" "),o("li",[e._v("cors跨域，通过后端服务器实现，Access-Control-Allow-Origin。")]),e._v(" "),o("li",[e._v("postMessage window的一个属性方法。")]),e._v(" "),o("li",[e._v("websocket")]),e._v(" "),o("li",[e._v("nginx反向代理")]),e._v(" "),o("li",[e._v("iframe跨域")])]),e._v(" "),o("p",[o("strong",[e._v("webpack proxy跨域")])]),e._v(" "),o("p",[e._v("首先需要明白webpack proxy跨域只能用作与开发阶段，临时解决本地请求服务器产生的跨域问题。并不适合线上环境。配置在webpack的devServer属性中。webpack中的devsever配置后，打包阶段在本地临时生成了一个node服务器，浏览器请求服务器相当于请求本地服务。")])])}),[],!1,null,null,null);t.default=n.exports}}]);